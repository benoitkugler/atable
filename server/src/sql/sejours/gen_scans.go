package sejours

// Code generated by gomacro/generator/go/sqlcrud. DO NOT EDIT.

import (
	"database/sql"
	"database/sql/driver"
	"encoding/json"
	"errors"
	"time"

	"github.com/benoitkugler/atable/sql/menus"
	"github.com/benoitkugler/atable/sql/orders"
	"github.com/benoitkugler/atable/sql/users"
	"github.com/lib/pq"
)

type scanner interface {
	Scan(...interface{}) error
}

// DB groups transaction like objects, and
// is implemented by *sql.DB and *sql.Tx
type DB interface {
	Exec(query string, args ...interface{}) (sql.Result, error)
	Query(query string, args ...interface{}) (*sql.Rows, error)
	QueryRow(query string, args ...interface{}) *sql.Row
	Prepare(query string) (*sql.Stmt, error)
}

func scanOneGroup(row scanner) (Group, error) {
	var item Group
	err := row.Scan(
		&item.Id,
		&item.Sejour,
		&item.Name,
		&item.Color,
		&item.Size,
	)
	return item, err
}

func ScanGroup(row *sql.Row) (Group, error) { return scanOneGroup(row) }

// SelectAll returns all the items in the groups table.
func SelectAllGroups(db DB) (Groups, error) {
	rows, err := db.Query("SELECT * FROM groups")
	if err != nil {
		return nil, err
	}
	return ScanGroups(rows)
}

// SelectGroup returns the entry matching 'id'.
func SelectGroup(tx DB, id IdGroup) (Group, error) {
	row := tx.QueryRow("SELECT * FROM groups WHERE id = $1", id)
	return ScanGroup(row)
}

// SelectGroups returns the entry matching the given 'ids'.
func SelectGroups(tx DB, ids ...IdGroup) (Groups, error) {
	rows, err := tx.Query("SELECT * FROM groups WHERE id = ANY($1)", IdGroupArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanGroups(rows)
}

type Groups map[IdGroup]Group

func (m Groups) IDs() []IdGroup {
	out := make([]IdGroup, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanGroups(rs *sql.Rows) (Groups, error) {
	var (
		s   Group
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Groups, 16)
	for rs.Next() {
		s, err = scanOneGroup(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Group in the database and returns the item with id filled.
func (item Group) Insert(tx DB) (out Group, err error) {
	row := tx.QueryRow(`INSERT INTO groups (
		sejour, name, color, size
		) VALUES (
		$1, $2, $3, $4
		) RETURNING *;
		`, item.Sejour, item.Name, item.Color, item.Size)
	return ScanGroup(row)
}

// Update Group in the database and returns the new version.
func (item Group) Update(tx DB) (out Group, err error) {
	row := tx.QueryRow(`UPDATE groups SET (
		sejour, name, color, size
		) = (
		$1, $2, $3, $4
		) WHERE id = $5 RETURNING *;
		`, item.Sejour, item.Name, item.Color, item.Size, item.Id)
	return ScanGroup(row)
}

// Deletes the Group and returns the item
func DeleteGroupById(tx DB, id IdGroup) (Group, error) {
	row := tx.QueryRow("DELETE FROM groups WHERE id = $1 RETURNING *;", id)
	return ScanGroup(row)
}

// Deletes the Group in the database and returns the ids.
func DeleteGroupsByIDs(tx DB, ids ...IdGroup) ([]IdGroup, error) {
	rows, err := tx.Query("DELETE FROM groups WHERE id = ANY($1) RETURNING id", IdGroupArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdGroupArray(rows)
}

// BySejour returns a map with 'Sejour' as keys.
func (items Groups) BySejour() map[IdSejour]Groups {
	out := make(map[IdSejour]Groups)
	for _, target := range items {
		dict := out[target.Sejour]
		if dict == nil {
			dict = make(Groups)
		}
		dict[target.Id] = target
		out[target.Sejour] = dict
	}
	return out
}

// Sejours returns the list of ids of Sejour
// contained in this table.
// They are not garanteed to be distinct.
func (items Groups) Sejours() []IdSejour {
	out := make([]IdSejour, 0, len(items))
	for _, target := range items {
		out = append(out, target.Sejour)
	}
	return out
}

func SelectGroupsBySejours(tx DB, sejours_ ...IdSejour) (Groups, error) {
	rows, err := tx.Query("SELECT * FROM groups WHERE sejour = ANY($1)", IdSejourArrayToPQ(sejours_))
	if err != nil {
		return nil, err
	}
	return ScanGroups(rows)
}

func DeleteGroupsBySejours(tx DB, sejours_ ...IdSejour) ([]IdGroup, error) {
	rows, err := tx.Query("DELETE FROM groups WHERE sejour = ANY($1) RETURNING id", IdSejourArrayToPQ(sejours_))
	if err != nil {
		return nil, err
	}
	return ScanIdGroupArray(rows)
}

func scanOneMeal(row scanner) (Meal, error) {
	var item Meal
	err := row.Scan(
		&item.Id,
		&item.Sejour,
		&item.Menu,
		&item.Jour,
		&item.AdditionalPeople,
		&item.Horaire,
	)
	return item, err
}

func ScanMeal(row *sql.Row) (Meal, error) { return scanOneMeal(row) }

// SelectAll returns all the items in the meals table.
func SelectAllMeals(db DB) (Meals, error) {
	rows, err := db.Query("SELECT * FROM meals")
	if err != nil {
		return nil, err
	}
	return ScanMeals(rows)
}

// SelectMeal returns the entry matching 'id'.
func SelectMeal(tx DB, id IdMeal) (Meal, error) {
	row := tx.QueryRow("SELECT * FROM meals WHERE id = $1", id)
	return ScanMeal(row)
}

// SelectMeals returns the entry matching the given 'ids'.
func SelectMeals(tx DB, ids ...IdMeal) (Meals, error) {
	rows, err := tx.Query("SELECT * FROM meals WHERE id = ANY($1)", IdMealArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanMeals(rows)
}

type Meals map[IdMeal]Meal

func (m Meals) IDs() []IdMeal {
	out := make([]IdMeal, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanMeals(rs *sql.Rows) (Meals, error) {
	var (
		s   Meal
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Meals, 16)
	for rs.Next() {
		s, err = scanOneMeal(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Meal in the database and returns the item with id filled.
func (item Meal) Insert(tx DB) (out Meal, err error) {
	row := tx.QueryRow(`INSERT INTO meals (
		sejour, menu, jour, additionalpeople, horaire
		) VALUES (
		$1, $2, $3, $4, $5
		) RETURNING *;
		`, item.Sejour, item.Menu, item.Jour, item.AdditionalPeople, item.Horaire)
	return ScanMeal(row)
}

// Update Meal in the database and returns the new version.
func (item Meal) Update(tx DB) (out Meal, err error) {
	row := tx.QueryRow(`UPDATE meals SET (
		sejour, menu, jour, additionalpeople, horaire
		) = (
		$1, $2, $3, $4, $5
		) WHERE id = $6 RETURNING *;
		`, item.Sejour, item.Menu, item.Jour, item.AdditionalPeople, item.Horaire, item.Id)
	return ScanMeal(row)
}

// Deletes the Meal and returns the item
func DeleteMealById(tx DB, id IdMeal) (Meal, error) {
	row := tx.QueryRow("DELETE FROM meals WHERE id = $1 RETURNING *;", id)
	return ScanMeal(row)
}

// Deletes the Meal in the database and returns the ids.
func DeleteMealsByIDs(tx DB, ids ...IdMeal) ([]IdMeal, error) {
	rows, err := tx.Query("DELETE FROM meals WHERE id = ANY($1) RETURNING id", IdMealArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdMealArray(rows)
}

// BySejour returns a map with 'Sejour' as keys.
func (items Meals) BySejour() map[IdSejour]Meals {
	out := make(map[IdSejour]Meals)
	for _, target := range items {
		dict := out[target.Sejour]
		if dict == nil {
			dict = make(Meals)
		}
		dict[target.Id] = target
		out[target.Sejour] = dict
	}
	return out
}

// Sejours returns the list of ids of Sejour
// contained in this table.
// They are not garanteed to be distinct.
func (items Meals) Sejours() []IdSejour {
	out := make([]IdSejour, 0, len(items))
	for _, target := range items {
		out = append(out, target.Sejour)
	}
	return out
}

func SelectMealsBySejours(tx DB, sejours_ ...IdSejour) (Meals, error) {
	rows, err := tx.Query("SELECT * FROM meals WHERE sejour = ANY($1)", IdSejourArrayToPQ(sejours_))
	if err != nil {
		return nil, err
	}
	return ScanMeals(rows)
}

func DeleteMealsBySejours(tx DB, sejours_ ...IdSejour) ([]IdMeal, error) {
	rows, err := tx.Query("DELETE FROM meals WHERE sejour = ANY($1) RETURNING id", IdSejourArrayToPQ(sejours_))
	if err != nil {
		return nil, err
	}
	return ScanIdMealArray(rows)
}

// ByMenu returns a map with 'Menu' as keys.
func (items Meals) ByMenu() map[menus.IdMenu]Meals {
	out := make(map[menus.IdMenu]Meals)
	for _, target := range items {
		dict := out[target.Menu]
		if dict == nil {
			dict = make(Meals)
		}
		dict[target.Id] = target
		out[target.Menu] = dict
	}
	return out
}

// Menus returns the list of ids of Menu
// contained in this table.
// They are not garanteed to be distinct.
func (items Meals) Menus() []menus.IdMenu {
	out := make([]menus.IdMenu, 0, len(items))
	for _, target := range items {
		out = append(out, target.Menu)
	}
	return out
}

func SelectMealsByMenus(tx DB, menus_ ...menus.IdMenu) (Meals, error) {
	rows, err := tx.Query("SELECT * FROM meals WHERE menu = ANY($1)", menus.IdMenuArrayToPQ(menus_))
	if err != nil {
		return nil, err
	}
	return ScanMeals(rows)
}

func DeleteMealsByMenus(tx DB, menus_ ...menus.IdMenu) ([]IdMeal, error) {
	rows, err := tx.Query("DELETE FROM meals WHERE menu = ANY($1) RETURNING id", menus.IdMenuArrayToPQ(menus_))
	if err != nil {
		return nil, err
	}
	return ScanIdMealArray(rows)
}

func scanOneMealGroup(row scanner) (MealGroup, error) {
	var item MealGroup
	err := row.Scan(
		&item.IdMeal,
		&item.IdGroup,
	)
	return item, err
}

func ScanMealGroup(row *sql.Row) (MealGroup, error) { return scanOneMealGroup(row) }

// SelectAll returns all the items in the meal_groups table.
func SelectAllMealGroups(db DB) (MealGroups, error) {
	rows, err := db.Query("SELECT * FROM meal_groups")
	if err != nil {
		return nil, err
	}
	return ScanMealGroups(rows)
}

type MealGroups []MealGroup

func ScanMealGroups(rs *sql.Rows) (MealGroups, error) {
	var (
		item MealGroup
		err  error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(MealGroups, 0, 16)
	for rs.Next() {
		item, err = scanOneMealGroup(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, item)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

func InsertMealGroup(db DB, item MealGroup) error {
	_, err := db.Exec(`INSERT INTO meal_groups (
			idmeal, idgroup
			) VALUES (
			$1, $2
			);
			`, item.IdMeal, item.IdGroup)
	if err != nil {
		return err
	}
	return nil
}

// Insert the links MealGroup in the database.
// It is a no-op if 'items' is empty.
func InsertManyMealGroups(tx *sql.Tx, items ...MealGroup) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("meal_groups",
		"idmeal",
		"idgroup",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdMeal, item.IdGroup)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link MealGroup from the database.
// Only the foreign keys IdMeal, IdGroup fields are used in 'item'.
func (item MealGroup) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM meal_groups WHERE IdMeal = $1 AND IdGroup = $2;`, item.IdMeal, item.IdGroup)
	return err
}

// ByIdMeal returns a map with 'IdMeal' as keys.
func (items MealGroups) ByIdMeal() map[IdMeal]MealGroups {
	out := make(map[IdMeal]MealGroups)
	for _, target := range items {
		out[target.IdMeal] = append(out[target.IdMeal], target)
	}
	return out
}

// IdMeals returns the list of ids of IdMeal
// contained in this link table.
// They are not garanteed to be distinct.
func (items MealGroups) IdMeals() []IdMeal {
	out := make([]IdMeal, len(items))
	for index, target := range items {
		out[index] = target.IdMeal
	}
	return out
}

func SelectMealGroupsByIdMeals(tx DB, idMeals_ ...IdMeal) (MealGroups, error) {
	rows, err := tx.Query("SELECT * FROM meal_groups WHERE idmeal = ANY($1)", IdMealArrayToPQ(idMeals_))
	if err != nil {
		return nil, err
	}
	return ScanMealGroups(rows)
}

func DeleteMealGroupsByIdMeals(tx DB, idMeals_ ...IdMeal) (MealGroups, error) {
	rows, err := tx.Query("DELETE FROM meal_groups WHERE idmeal = ANY($1) RETURNING *", IdMealArrayToPQ(idMeals_))
	if err != nil {
		return nil, err
	}
	return ScanMealGroups(rows)
}

// ByIdGroup returns a map with 'IdGroup' as keys.
func (items MealGroups) ByIdGroup() map[IdGroup]MealGroups {
	out := make(map[IdGroup]MealGroups)
	for _, target := range items {
		out[target.IdGroup] = append(out[target.IdGroup], target)
	}
	return out
}

// IdGroups returns the list of ids of IdGroup
// contained in this link table.
// They are not garanteed to be distinct.
func (items MealGroups) IdGroups() []IdGroup {
	out := make([]IdGroup, len(items))
	for index, target := range items {
		out[index] = target.IdGroup
	}
	return out
}

func SelectMealGroupsByIdGroups(tx DB, idGroups_ ...IdGroup) (MealGroups, error) {
	rows, err := tx.Query("SELECT * FROM meal_groups WHERE idgroup = ANY($1)", IdGroupArrayToPQ(idGroups_))
	if err != nil {
		return nil, err
	}
	return ScanMealGroups(rows)
}

func DeleteMealGroupsByIdGroups(tx DB, idGroups_ ...IdGroup) (MealGroups, error) {
	rows, err := tx.Query("DELETE FROM meal_groups WHERE idgroup = ANY($1) RETURNING *", IdGroupArrayToPQ(idGroups_))
	if err != nil {
		return nil, err
	}
	return ScanMealGroups(rows)
}

// SelectMealGroupByIdMealAndIdGroup return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectMealGroupByIdMealAndIdGroup(tx DB, idMeal IdMeal, idGroup IdGroup) (item MealGroup, found bool, err error) {
	row := tx.QueryRow("SELECT * FROM meal_groups WHERE IdMeal = $1 AND IdGroup = $2", idMeal, idGroup)
	item, err = ScanMealGroup(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func scanOneSejour(row scanner) (Sejour, error) {
	var item Sejour
	err := row.Scan(
		&item.Id,
		&item.Owner,
		&item.Start,
		&item.Name,
		&item.IdProfile,
	)
	return item, err
}

func ScanSejour(row *sql.Row) (Sejour, error) { return scanOneSejour(row) }

// SelectAll returns all the items in the sejours table.
func SelectAllSejours(db DB) (Sejours, error) {
	rows, err := db.Query("SELECT * FROM sejours")
	if err != nil {
		return nil, err
	}
	return ScanSejours(rows)
}

// SelectSejour returns the entry matching 'id'.
func SelectSejour(tx DB, id IdSejour) (Sejour, error) {
	row := tx.QueryRow("SELECT * FROM sejours WHERE id = $1", id)
	return ScanSejour(row)
}

// SelectSejours returns the entry matching the given 'ids'.
func SelectSejours(tx DB, ids ...IdSejour) (Sejours, error) {
	rows, err := tx.Query("SELECT * FROM sejours WHERE id = ANY($1)", IdSejourArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanSejours(rows)
}

type Sejours map[IdSejour]Sejour

func (m Sejours) IDs() []IdSejour {
	out := make([]IdSejour, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanSejours(rs *sql.Rows) (Sejours, error) {
	var (
		s   Sejour
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Sejours, 16)
	for rs.Next() {
		s, err = scanOneSejour(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Sejour in the database and returns the item with id filled.
func (item Sejour) Insert(tx DB) (out Sejour, err error) {
	row := tx.QueryRow(`INSERT INTO sejours (
		owner, start, name, idprofile
		) VALUES (
		$1, $2, $3, $4
		) RETURNING *;
		`, item.Owner, item.Start, item.Name, item.IdProfile)
	return ScanSejour(row)
}

// Update Sejour in the database and returns the new version.
func (item Sejour) Update(tx DB) (out Sejour, err error) {
	row := tx.QueryRow(`UPDATE sejours SET (
		owner, start, name, idprofile
		) = (
		$1, $2, $3, $4
		) WHERE id = $5 RETURNING *;
		`, item.Owner, item.Start, item.Name, item.IdProfile, item.Id)
	return ScanSejour(row)
}

// Deletes the Sejour and returns the item
func DeleteSejourById(tx DB, id IdSejour) (Sejour, error) {
	row := tx.QueryRow("DELETE FROM sejours WHERE id = $1 RETURNING *;", id)
	return ScanSejour(row)
}

// Deletes the Sejour in the database and returns the ids.
func DeleteSejoursByIDs(tx DB, ids ...IdSejour) ([]IdSejour, error) {
	rows, err := tx.Query("DELETE FROM sejours WHERE id = ANY($1) RETURNING id", IdSejourArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdSejourArray(rows)
}

// ByOwner returns a map with 'Owner' as keys.
func (items Sejours) ByOwner() map[users.IdUser]Sejours {
	out := make(map[users.IdUser]Sejours)
	for _, target := range items {
		dict := out[target.Owner]
		if dict == nil {
			dict = make(Sejours)
		}
		dict[target.Id] = target
		out[target.Owner] = dict
	}
	return out
}

// Owners returns the list of ids of Owner
// contained in this table.
// They are not garanteed to be distinct.
func (items Sejours) Owners() []users.IdUser {
	out := make([]users.IdUser, 0, len(items))
	for _, target := range items {
		out = append(out, target.Owner)
	}
	return out
}

func SelectSejoursByOwners(tx DB, owners_ ...users.IdUser) (Sejours, error) {
	rows, err := tx.Query("SELECT * FROM sejours WHERE owner = ANY($1)", users.IdUserArrayToPQ(owners_))
	if err != nil {
		return nil, err
	}
	return ScanSejours(rows)
}

func DeleteSejoursByOwners(tx DB, owners_ ...users.IdUser) ([]IdSejour, error) {
	rows, err := tx.Query("DELETE FROM sejours WHERE owner = ANY($1) RETURNING id", users.IdUserArrayToPQ(owners_))
	if err != nil {
		return nil, err
	}
	return ScanIdSejourArray(rows)
}

func SelectSejoursByIdProfiles(tx DB, idProfiles_ ...orders.IdProfile) (Sejours, error) {
	rows, err := tx.Query("SELECT * FROM sejours WHERE idprofile = ANY($1)", orders.IdProfileArrayToPQ(idProfiles_))
	if err != nil {
		return nil, err
	}
	return ScanSejours(rows)
}

func DeleteSejoursByIdProfiles(tx DB, idProfiles_ ...orders.IdProfile) ([]IdSejour, error) {
	rows, err := tx.Query("DELETE FROM sejours WHERE idprofile = ANY($1) RETURNING id", orders.IdProfileArrayToPQ(idProfiles_))
	if err != nil {
		return nil, err
	}
	return ScanIdSejourArray(rows)
}

// SelectSejourByIdAndOwner return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectSejourByIdAndOwner(tx DB, id IdSejour, owner users.IdUser) (item Sejour, found bool, err error) {
	row := tx.QueryRow("SELECT * FROM sejours WHERE Id = $1 AND Owner = $2", id, owner)
	item, err = ScanSejour(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func loadJSON(out interface{}, src interface{}) error {
	if src == nil {
		return nil //zero value out
	}
	bs, ok := src.([]byte)
	if !ok {
		return errors.New("not a []byte")
	}
	return json.Unmarshal(bs, out)
}

func dumpJSON(s interface{}) (driver.Value, error) {
	b, err := json.Marshal(s)
	if err != nil {
		return nil, err
	}
	return driver.Value(string(b)), nil
}

func (s *Date) Scan(src interface{}) error {
	var tmp pq.NullTime
	err := tmp.Scan(src)
	if err != nil {
		return err
	}
	*s = Date(tmp.Time)
	return nil
}

func (s Date) Value() (driver.Value, error) {
	return pq.NullTime{Time: time.Time(s), Valid: true}.Value()
}

func IdGroupArrayToPQ(ids []IdGroup) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdGroupArray scans the result of a query returning a
// list of ID's.
func ScanIdGroupArray(rs *sql.Rows) ([]IdGroup, error) {
	defer rs.Close()
	ints := make([]IdGroup, 0, 16)
	var err error
	for rs.Next() {
		var s IdGroup
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

type IdGroupSet map[IdGroup]bool

func NewIdGroupSetFrom(ids []IdGroup) IdGroupSet {
	out := make(IdGroupSet, len(ids))
	for _, key := range ids {
		out[key] = true
	}
	return out
}

func (s IdGroupSet) Add(id IdGroup) { s[id] = true }

func (s IdGroupSet) Has(id IdGroup) bool { return s[id] }

func (s IdGroupSet) Keys() []IdGroup {
	out := make([]IdGroup, 0, len(s))
	for k := range s {
		out = append(out, k)
	}
	return out
}

func IdMealArrayToPQ(ids []IdMeal) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdMealArray scans the result of a query returning a
// list of ID's.
func ScanIdMealArray(rs *sql.Rows) ([]IdMeal, error) {
	defer rs.Close()
	ints := make([]IdMeal, 0, 16)
	var err error
	for rs.Next() {
		var s IdMeal
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

type IdMealSet map[IdMeal]bool

func NewIdMealSetFrom(ids []IdMeal) IdMealSet {
	out := make(IdMealSet, len(ids))
	for _, key := range ids {
		out[key] = true
	}
	return out
}

func (s IdMealSet) Add(id IdMeal) { s[id] = true }

func (s IdMealSet) Has(id IdMeal) bool { return s[id] }

func (s IdMealSet) Keys() []IdMeal {
	out := make([]IdMeal, 0, len(s))
	for k := range s {
		out = append(out, k)
	}
	return out
}

func IdSejourArrayToPQ(ids []IdSejour) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdSejourArray scans the result of a query returning a
// list of ID's.
func ScanIdSejourArray(rs *sql.Rows) ([]IdSejour, error) {
	defer rs.Close()
	ints := make([]IdSejour, 0, 16)
	var err error
	for rs.Next() {
		var s IdSejour
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

type IdSejourSet map[IdSejour]bool

func NewIdSejourSetFrom(ids []IdSejour) IdSejourSet {
	out := make(IdSejourSet, len(ids))
	for _, key := range ids {
		out[key] = true
	}
	return out
}

func (s IdSejourSet) Add(id IdSejour) { s[id] = true }

func (s IdSejourSet) Has(id IdSejour) bool { return s[id] }

func (s IdSejourSet) Keys() []IdSejour {
	out := make([]IdSejour, 0, len(s))
	for k := range s {
		out = append(out, k)
	}
	return out
}

func (s *OptionnalIdProfile) Scan(src interface{}) error {
	var tmp sql.NullInt64
	err := tmp.Scan(src)
	if err != nil {
		return err
	}
	*s = OptionnalIdProfile{
		Valid:     tmp.Valid,
		IdProfile: orders.IdProfile(tmp.Int64),
	}
	return nil
}

func (s OptionnalIdProfile) Value() (driver.Value, error) {
	return sql.NullInt64{
		Int64: int64(s.IdProfile),
		Valid: s.Valid}.Value()
}
