package menus

// Code generated by gomacro/generator/go/sqlcrud. DO NOT EDIT.

import (
	"database/sql"
	"database/sql/driver"
	"encoding/json"
	"errors"

	"github.com/benoitkugler/atable/sql/users"
	"github.com/lib/pq"
)

type scanner interface {
	Scan(...interface{}) error
}

// DB groups transaction like objects, and
// is implemented by *sql.DB and *sql.Tx
type DB interface {
	Exec(query string, args ...interface{}) (sql.Result, error)
	Query(query string, args ...interface{}) (*sql.Rows, error)
	QueryRow(query string, args ...interface{}) *sql.Row
	Prepare(query string) (*sql.Stmt, error)
}

func scanOneIngredient(row scanner) (Ingredient, error) {
	var item Ingredient
	err := row.Scan(
		&item.Id,
		&item.Name,
		&item.Kind,
	)
	return item, err
}

func ScanIngredient(row *sql.Row) (Ingredient, error) { return scanOneIngredient(row) }

// SelectAll returns all the items in the ingredients table.
func SelectAllIngredients(db DB) (Ingredients, error) {
	rows, err := db.Query("SELECT * FROM ingredients")
	if err != nil {
		return nil, err
	}
	return ScanIngredients(rows)
}

// SelectIngredient returns the entry matching 'id'.
func SelectIngredient(tx DB, id IdIngredient) (Ingredient, error) {
	row := tx.QueryRow("SELECT * FROM ingredients WHERE id = $1", id)
	return ScanIngredient(row)
}

// SelectIngredients returns the entry matching the given 'ids'.
func SelectIngredients(tx DB, ids ...IdIngredient) (Ingredients, error) {
	rows, err := tx.Query("SELECT * FROM ingredients WHERE id = ANY($1)", IdIngredientArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIngredients(rows)
}

type Ingredients map[IdIngredient]Ingredient

func (m Ingredients) IDs() []IdIngredient {
	out := make([]IdIngredient, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanIngredients(rs *sql.Rows) (Ingredients, error) {
	var (
		s   Ingredient
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Ingredients, 16)
	for rs.Next() {
		s, err = scanOneIngredient(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Ingredient in the database and returns the item with id filled.
func (item Ingredient) Insert(tx DB) (out Ingredient, err error) {
	row := tx.QueryRow(`INSERT INTO ingredients (
		name, kind
		) VALUES (
		$1, $2
		) RETURNING *;
		`, item.Name, item.Kind)
	return ScanIngredient(row)
}

// Update Ingredient in the database and returns the new version.
func (item Ingredient) Update(tx DB) (out Ingredient, err error) {
	row := tx.QueryRow(`UPDATE ingredients SET (
		name, kind
		) = (
		$1, $2
		) WHERE id = $3 RETURNING *;
		`, item.Name, item.Kind, item.Id)
	return ScanIngredient(row)
}

// Deletes the Ingredient and returns the item
func DeleteIngredientById(tx DB, id IdIngredient) (Ingredient, error) {
	row := tx.QueryRow("DELETE FROM ingredients WHERE id = $1 RETURNING *;", id)
	return ScanIngredient(row)
}

// Deletes the Ingredient in the database and returns the ids.
func DeleteIngredientsByIDs(tx DB, ids ...IdIngredient) ([]IdIngredient, error) {
	rows, err := tx.Query("DELETE FROM ingredients WHERE id = ANY($1) RETURNING id", IdIngredientArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdIngredientArray(rows)
}

// SelectIngredientByName return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectIngredientByName(tx DB, name string) (item Ingredient, found bool, err error) {
	row := tx.QueryRow("SELECT * FROM ingredients WHERE Name = $1", name)
	item, err = ScanIngredient(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func scanOneMenu(row scanner) (Menu, error) {
	var item Menu
	err := row.Scan(
		&item.Id,
		&item.Owner,
		&item.IsFavorite,
	)
	return item, err
}

func ScanMenu(row *sql.Row) (Menu, error) { return scanOneMenu(row) }

// SelectAll returns all the items in the menus table.
func SelectAllMenus(db DB) (Menus, error) {
	rows, err := db.Query("SELECT * FROM menus")
	if err != nil {
		return nil, err
	}
	return ScanMenus(rows)
}

// SelectMenu returns the entry matching 'id'.
func SelectMenu(tx DB, id IdMenu) (Menu, error) {
	row := tx.QueryRow("SELECT * FROM menus WHERE id = $1", id)
	return ScanMenu(row)
}

// SelectMenus returns the entry matching the given 'ids'.
func SelectMenus(tx DB, ids ...IdMenu) (Menus, error) {
	rows, err := tx.Query("SELECT * FROM menus WHERE id = ANY($1)", IdMenuArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanMenus(rows)
}

type Menus map[IdMenu]Menu

func (m Menus) IDs() []IdMenu {
	out := make([]IdMenu, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanMenus(rs *sql.Rows) (Menus, error) {
	var (
		s   Menu
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Menus, 16)
	for rs.Next() {
		s, err = scanOneMenu(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Menu in the database and returns the item with id filled.
func (item Menu) Insert(tx DB) (out Menu, err error) {
	row := tx.QueryRow(`INSERT INTO menus (
		owner, isfavorite
		) VALUES (
		$1, $2
		) RETURNING *;
		`, item.Owner, item.IsFavorite)
	return ScanMenu(row)
}

// Update Menu in the database and returns the new version.
func (item Menu) Update(tx DB) (out Menu, err error) {
	row := tx.QueryRow(`UPDATE menus SET (
		owner, isfavorite
		) = (
		$1, $2
		) WHERE id = $3 RETURNING *;
		`, item.Owner, item.IsFavorite, item.Id)
	return ScanMenu(row)
}

// Deletes the Menu and returns the item
func DeleteMenuById(tx DB, id IdMenu) (Menu, error) {
	row := tx.QueryRow("DELETE FROM menus WHERE id = $1 RETURNING *;", id)
	return ScanMenu(row)
}

// Deletes the Menu in the database and returns the ids.
func DeleteMenusByIDs(tx DB, ids ...IdMenu) ([]IdMenu, error) {
	rows, err := tx.Query("DELETE FROM menus WHERE id = ANY($1) RETURNING id", IdMenuArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdMenuArray(rows)
}

// ByOwner returns a map with 'Owner' as keys.
func (items Menus) ByOwner() map[users.IdUser]Menus {
	out := make(map[users.IdUser]Menus)
	for _, target := range items {
		dict := out[target.Owner]
		if dict == nil {
			dict = make(Menus)
		}
		dict[target.Id] = target
		out[target.Owner] = dict
	}
	return out
}

// Owners returns the list of ids of Owner
// contained in this table.
// They are not garanteed to be distinct.
func (items Menus) Owners() []users.IdUser {
	out := make([]users.IdUser, 0, len(items))
	for _, target := range items {
		out = append(out, target.Owner)
	}
	return out
}

func SelectMenusByOwners(tx DB, owners_ ...users.IdUser) (Menus, error) {
	rows, err := tx.Query("SELECT * FROM menus WHERE owner = ANY($1)", users.IdUserArrayToPQ(owners_))
	if err != nil {
		return nil, err
	}
	return ScanMenus(rows)
}

func DeleteMenusByOwners(tx DB, owners_ ...users.IdUser) ([]IdMenu, error) {
	rows, err := tx.Query("DELETE FROM menus WHERE owner = ANY($1) RETURNING id", users.IdUserArrayToPQ(owners_))
	if err != nil {
		return nil, err
	}
	return ScanIdMenuArray(rows)
}

func scanOneMenuIngredient(row scanner) (MenuIngredient, error) {
	var item MenuIngredient
	err := row.Scan(
		&item.IdMenu,
		&item.IdIngredient,
		&item.Quantity,
		&item.Plat,
	)
	return item, err
}

func ScanMenuIngredient(row *sql.Row) (MenuIngredient, error) { return scanOneMenuIngredient(row) }

// SelectAll returns all the items in the menu_ingredients table.
func SelectAllMenuIngredients(db DB) (MenuIngredients, error) {
	rows, err := db.Query("SELECT * FROM menu_ingredients")
	if err != nil {
		return nil, err
	}
	return ScanMenuIngredients(rows)
}

type MenuIngredients []MenuIngredient

func ScanMenuIngredients(rs *sql.Rows) (MenuIngredients, error) {
	var (
		item MenuIngredient
		err  error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(MenuIngredients, 0, 16)
	for rs.Next() {
		item, err = scanOneMenuIngredient(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, item)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert the links MenuIngredient in the database.
// It is a no-op if 'items' is empty.
func InsertManyMenuIngredients(tx *sql.Tx, items ...MenuIngredient) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("menu_ingredients",
		"idmenu",
		"idingredient",
		"quantity",
		"plat",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdMenu, item.IdIngredient, item.Quantity, item.Plat)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link MenuIngredient from the database.
// Only the foreign keys IdMenu, IdIngredient fields are used in 'item'.
func (item MenuIngredient) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM menu_ingredients WHERE IdMenu = $1 AND IdIngredient = $2;`, item.IdMenu, item.IdIngredient)
	return err
}

// ByIdMenu returns a map with 'IdMenu' as keys.
func (items MenuIngredients) ByIdMenu() map[IdMenu]MenuIngredients {
	out := make(map[IdMenu]MenuIngredients)
	for _, target := range items {
		out[target.IdMenu] = append(out[target.IdMenu], target)
	}
	return out
}

// IdMenus returns the list of ids of IdMenu
// contained in this link table.
// They are not garanteed to be distinct.
func (items MenuIngredients) IdMenus() []IdMenu {
	out := make([]IdMenu, len(items))
	for index, target := range items {
		out[index] = target.IdMenu
	}
	return out
}

func SelectMenuIngredientsByIdMenus(tx DB, idMenus_ ...IdMenu) (MenuIngredients, error) {
	rows, err := tx.Query("SELECT * FROM menu_ingredients WHERE idmenu = ANY($1)", IdMenuArrayToPQ(idMenus_))
	if err != nil {
		return nil, err
	}
	return ScanMenuIngredients(rows)
}

func DeleteMenuIngredientsByIdMenus(tx DB, idMenus_ ...IdMenu) (MenuIngredients, error) {
	rows, err := tx.Query("DELETE FROM menu_ingredients WHERE idmenu = ANY($1) RETURNING *", IdMenuArrayToPQ(idMenus_))
	if err != nil {
		return nil, err
	}
	return ScanMenuIngredients(rows)
}

// ByIdIngredient returns a map with 'IdIngredient' as keys.
func (items MenuIngredients) ByIdIngredient() map[IdIngredient]MenuIngredients {
	out := make(map[IdIngredient]MenuIngredients)
	for _, target := range items {
		out[target.IdIngredient] = append(out[target.IdIngredient], target)
	}
	return out
}

// IdIngredients returns the list of ids of IdIngredient
// contained in this link table.
// They are not garanteed to be distinct.
func (items MenuIngredients) IdIngredients() []IdIngredient {
	out := make([]IdIngredient, len(items))
	for index, target := range items {
		out[index] = target.IdIngredient
	}
	return out
}

func SelectMenuIngredientsByIdIngredients(tx DB, idIngredients_ ...IdIngredient) (MenuIngredients, error) {
	rows, err := tx.Query("SELECT * FROM menu_ingredients WHERE idingredient = ANY($1)", IdIngredientArrayToPQ(idIngredients_))
	if err != nil {
		return nil, err
	}
	return ScanMenuIngredients(rows)
}

func DeleteMenuIngredientsByIdIngredients(tx DB, idIngredients_ ...IdIngredient) (MenuIngredients, error) {
	rows, err := tx.Query("DELETE FROM menu_ingredients WHERE idingredient = ANY($1) RETURNING *", IdIngredientArrayToPQ(idIngredients_))
	if err != nil {
		return nil, err
	}
	return ScanMenuIngredients(rows)
}

func scanOneMenuReceipe(row scanner) (MenuReceipe, error) {
	var item MenuReceipe
	err := row.Scan(
		&item.IdMenu,
		&item.IdReceipe,
	)
	return item, err
}

func ScanMenuReceipe(row *sql.Row) (MenuReceipe, error) { return scanOneMenuReceipe(row) }

// SelectAll returns all the items in the menu_receipes table.
func SelectAllMenuReceipes(db DB) (MenuReceipes, error) {
	rows, err := db.Query("SELECT * FROM menu_receipes")
	if err != nil {
		return nil, err
	}
	return ScanMenuReceipes(rows)
}

type MenuReceipes []MenuReceipe

func ScanMenuReceipes(rs *sql.Rows) (MenuReceipes, error) {
	var (
		item MenuReceipe
		err  error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(MenuReceipes, 0, 16)
	for rs.Next() {
		item, err = scanOneMenuReceipe(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, item)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert the links MenuReceipe in the database.
// It is a no-op if 'items' is empty.
func InsertManyMenuReceipes(tx *sql.Tx, items ...MenuReceipe) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("menu_receipes",
		"idmenu",
		"idreceipe",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdMenu, item.IdReceipe)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link MenuReceipe from the database.
// Only the foreign keys IdMenu, IdReceipe fields are used in 'item'.
func (item MenuReceipe) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM menu_receipes WHERE IdMenu = $1 AND IdReceipe = $2;`, item.IdMenu, item.IdReceipe)
	return err
}

// ByIdMenu returns a map with 'IdMenu' as keys.
func (items MenuReceipes) ByIdMenu() map[IdMenu]MenuReceipes {
	out := make(map[IdMenu]MenuReceipes)
	for _, target := range items {
		out[target.IdMenu] = append(out[target.IdMenu], target)
	}
	return out
}

// IdMenus returns the list of ids of IdMenu
// contained in this link table.
// They are not garanteed to be distinct.
func (items MenuReceipes) IdMenus() []IdMenu {
	out := make([]IdMenu, len(items))
	for index, target := range items {
		out[index] = target.IdMenu
	}
	return out
}

func SelectMenuReceipesByIdMenus(tx DB, idMenus_ ...IdMenu) (MenuReceipes, error) {
	rows, err := tx.Query("SELECT * FROM menu_receipes WHERE idmenu = ANY($1)", IdMenuArrayToPQ(idMenus_))
	if err != nil {
		return nil, err
	}
	return ScanMenuReceipes(rows)
}

func DeleteMenuReceipesByIdMenus(tx DB, idMenus_ ...IdMenu) (MenuReceipes, error) {
	rows, err := tx.Query("DELETE FROM menu_receipes WHERE idmenu = ANY($1) RETURNING *", IdMenuArrayToPQ(idMenus_))
	if err != nil {
		return nil, err
	}
	return ScanMenuReceipes(rows)
}

// ByIdReceipe returns a map with 'IdReceipe' as keys.
func (items MenuReceipes) ByIdReceipe() map[IdReceipe]MenuReceipes {
	out := make(map[IdReceipe]MenuReceipes)
	for _, target := range items {
		out[target.IdReceipe] = append(out[target.IdReceipe], target)
	}
	return out
}

// IdReceipes returns the list of ids of IdReceipe
// contained in this link table.
// They are not garanteed to be distinct.
func (items MenuReceipes) IdReceipes() []IdReceipe {
	out := make([]IdReceipe, len(items))
	for index, target := range items {
		out[index] = target.IdReceipe
	}
	return out
}

func SelectMenuReceipesByIdReceipes(tx DB, idReceipes_ ...IdReceipe) (MenuReceipes, error) {
	rows, err := tx.Query("SELECT * FROM menu_receipes WHERE idreceipe = ANY($1)", IdReceipeArrayToPQ(idReceipes_))
	if err != nil {
		return nil, err
	}
	return ScanMenuReceipes(rows)
}

func DeleteMenuReceipesByIdReceipes(tx DB, idReceipes_ ...IdReceipe) (MenuReceipes, error) {
	rows, err := tx.Query("DELETE FROM menu_receipes WHERE idreceipe = ANY($1) RETURNING *", IdReceipeArrayToPQ(idReceipes_))
	if err != nil {
		return nil, err
	}
	return ScanMenuReceipes(rows)
}

func scanOneReceipe(row scanner) (Receipe, error) {
	var item Receipe
	err := row.Scan(
		&item.Id,
		&item.Owner,
		&item.Plat,
		&item.Name,
		&item.Description,
	)
	return item, err
}

func ScanReceipe(row *sql.Row) (Receipe, error) { return scanOneReceipe(row) }

// SelectAll returns all the items in the receipes table.
func SelectAllReceipes(db DB) (Receipes, error) {
	rows, err := db.Query("SELECT * FROM receipes")
	if err != nil {
		return nil, err
	}
	return ScanReceipes(rows)
}

// SelectReceipe returns the entry matching 'id'.
func SelectReceipe(tx DB, id IdReceipe) (Receipe, error) {
	row := tx.QueryRow("SELECT * FROM receipes WHERE id = $1", id)
	return ScanReceipe(row)
}

// SelectReceipes returns the entry matching the given 'ids'.
func SelectReceipes(tx DB, ids ...IdReceipe) (Receipes, error) {
	rows, err := tx.Query("SELECT * FROM receipes WHERE id = ANY($1)", IdReceipeArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanReceipes(rows)
}

type Receipes map[IdReceipe]Receipe

func (m Receipes) IDs() []IdReceipe {
	out := make([]IdReceipe, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanReceipes(rs *sql.Rows) (Receipes, error) {
	var (
		s   Receipe
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Receipes, 16)
	for rs.Next() {
		s, err = scanOneReceipe(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Receipe in the database and returns the item with id filled.
func (item Receipe) Insert(tx DB) (out Receipe, err error) {
	row := tx.QueryRow(`INSERT INTO receipes (
		owner, plat, name, description
		) VALUES (
		$1, $2, $3, $4
		) RETURNING *;
		`, item.Owner, item.Plat, item.Name, item.Description)
	return ScanReceipe(row)
}

// Update Receipe in the database and returns the new version.
func (item Receipe) Update(tx DB) (out Receipe, err error) {
	row := tx.QueryRow(`UPDATE receipes SET (
		owner, plat, name, description
		) = (
		$1, $2, $3, $4
		) WHERE id = $5 RETURNING *;
		`, item.Owner, item.Plat, item.Name, item.Description, item.Id)
	return ScanReceipe(row)
}

// Deletes the Receipe and returns the item
func DeleteReceipeById(tx DB, id IdReceipe) (Receipe, error) {
	row := tx.QueryRow("DELETE FROM receipes WHERE id = $1 RETURNING *;", id)
	return ScanReceipe(row)
}

// Deletes the Receipe in the database and returns the ids.
func DeleteReceipesByIDs(tx DB, ids ...IdReceipe) ([]IdReceipe, error) {
	rows, err := tx.Query("DELETE FROM receipes WHERE id = ANY($1) RETURNING id", IdReceipeArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdReceipeArray(rows)
}

// ByOwner returns a map with 'Owner' as keys.
func (items Receipes) ByOwner() map[users.IdUser]Receipes {
	out := make(map[users.IdUser]Receipes)
	for _, target := range items {
		dict := out[target.Owner]
		if dict == nil {
			dict = make(Receipes)
		}
		dict[target.Id] = target
		out[target.Owner] = dict
	}
	return out
}

// Owners returns the list of ids of Owner
// contained in this table.
// They are not garanteed to be distinct.
func (items Receipes) Owners() []users.IdUser {
	out := make([]users.IdUser, 0, len(items))
	for _, target := range items {
		out = append(out, target.Owner)
	}
	return out
}

func SelectReceipesByOwners(tx DB, owners_ ...users.IdUser) (Receipes, error) {
	rows, err := tx.Query("SELECT * FROM receipes WHERE owner = ANY($1)", users.IdUserArrayToPQ(owners_))
	if err != nil {
		return nil, err
	}
	return ScanReceipes(rows)
}

func DeleteReceipesByOwners(tx DB, owners_ ...users.IdUser) ([]IdReceipe, error) {
	rows, err := tx.Query("DELETE FROM receipes WHERE owner = ANY($1) RETURNING id", users.IdUserArrayToPQ(owners_))
	if err != nil {
		return nil, err
	}
	return ScanIdReceipeArray(rows)
}

func scanOneReceipeItem(row scanner) (ReceipeItem, error) {
	var item ReceipeItem
	err := row.Scan(
		&item.IdReceipe,
		&item.IdIngredient,
		&item.Quantity,
	)
	return item, err
}

func ScanReceipeItem(row *sql.Row) (ReceipeItem, error) { return scanOneReceipeItem(row) }

// SelectAll returns all the items in the receipe_items table.
func SelectAllReceipeItems(db DB) (ReceipeItems, error) {
	rows, err := db.Query("SELECT * FROM receipe_items")
	if err != nil {
		return nil, err
	}
	return ScanReceipeItems(rows)
}

type ReceipeItems []ReceipeItem

func ScanReceipeItems(rs *sql.Rows) (ReceipeItems, error) {
	var (
		item ReceipeItem
		err  error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(ReceipeItems, 0, 16)
	for rs.Next() {
		item, err = scanOneReceipeItem(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, item)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert the links ReceipeItem in the database.
// It is a no-op if 'items' is empty.
func InsertManyReceipeItems(tx *sql.Tx, items ...ReceipeItem) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("receipe_items",
		"idreceipe",
		"idingredient",
		"quantity",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdReceipe, item.IdIngredient, item.Quantity)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link ReceipeItem from the database.
// Only the foreign keys IdReceipe, IdIngredient fields are used in 'item'.
func (item ReceipeItem) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM receipe_items WHERE IdReceipe = $1 AND IdIngredient = $2;`, item.IdReceipe, item.IdIngredient)
	return err
}

// ByIdReceipe returns a map with 'IdReceipe' as keys.
func (items ReceipeItems) ByIdReceipe() map[IdReceipe]ReceipeItems {
	out := make(map[IdReceipe]ReceipeItems)
	for _, target := range items {
		out[target.IdReceipe] = append(out[target.IdReceipe], target)
	}
	return out
}

// IdReceipes returns the list of ids of IdReceipe
// contained in this link table.
// They are not garanteed to be distinct.
func (items ReceipeItems) IdReceipes() []IdReceipe {
	out := make([]IdReceipe, len(items))
	for index, target := range items {
		out[index] = target.IdReceipe
	}
	return out
}

func SelectReceipeItemsByIdReceipes(tx DB, idReceipes_ ...IdReceipe) (ReceipeItems, error) {
	rows, err := tx.Query("SELECT * FROM receipe_items WHERE idreceipe = ANY($1)", IdReceipeArrayToPQ(idReceipes_))
	if err != nil {
		return nil, err
	}
	return ScanReceipeItems(rows)
}

func DeleteReceipeItemsByIdReceipes(tx DB, idReceipes_ ...IdReceipe) (ReceipeItems, error) {
	rows, err := tx.Query("DELETE FROM receipe_items WHERE idreceipe = ANY($1) RETURNING *", IdReceipeArrayToPQ(idReceipes_))
	if err != nil {
		return nil, err
	}
	return ScanReceipeItems(rows)
}

// ByIdIngredient returns a map with 'IdIngredient' as keys.
func (items ReceipeItems) ByIdIngredient() map[IdIngredient]ReceipeItems {
	out := make(map[IdIngredient]ReceipeItems)
	for _, target := range items {
		out[target.IdIngredient] = append(out[target.IdIngredient], target)
	}
	return out
}

// IdIngredients returns the list of ids of IdIngredient
// contained in this link table.
// They are not garanteed to be distinct.
func (items ReceipeItems) IdIngredients() []IdIngredient {
	out := make([]IdIngredient, len(items))
	for index, target := range items {
		out[index] = target.IdIngredient
	}
	return out
}

func SelectReceipeItemsByIdIngredients(tx DB, idIngredients_ ...IdIngredient) (ReceipeItems, error) {
	rows, err := tx.Query("SELECT * FROM receipe_items WHERE idingredient = ANY($1)", IdIngredientArrayToPQ(idIngredients_))
	if err != nil {
		return nil, err
	}
	return ScanReceipeItems(rows)
}

func DeleteReceipeItemsByIdIngredients(tx DB, idIngredients_ ...IdIngredient) (ReceipeItems, error) {
	rows, err := tx.Query("DELETE FROM receipe_items WHERE idingredient = ANY($1) RETURNING *", IdIngredientArrayToPQ(idIngredients_))
	if err != nil {
		return nil, err
	}
	return ScanReceipeItems(rows)
}

// SelectReceipeItemByIdReceipeAndIdIngredient return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectReceipeItemByIdReceipeAndIdIngredient(tx DB, idReceipe IdReceipe, idIngredient IdIngredient) (item ReceipeItem, found bool, err error) {
	row := tx.QueryRow("SELECT * FROM receipe_items WHERE IdReceipe = $1 AND IdIngredient = $2", idReceipe, idIngredient)
	item, err = ScanReceipeItem(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

// SelectReceipeByName return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectReceipeByName(tx DB, name string) (item Receipe, found bool, err error) {
	row := tx.QueryRow("SELECT * FROM receipes WHERE Name = $1", name)
	item, err = ScanReceipe(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func loadJSON(out interface{}, src interface{}) error {
	if src == nil {
		return nil //zero value out
	}
	bs, ok := src.([]byte)
	if !ok {
		return errors.New("not a []byte")
	}
	return json.Unmarshal(bs, out)
}

func dumpJSON(s interface{}) (driver.Value, error) {
	b, err := json.Marshal(s)
	if err != nil {
		return nil, err
	}
	return driver.Value(string(b)), nil
}

func IdIngredientArrayToPQ(ids []IdIngredient) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdIngredientArray scans the result of a query returning a
// list of ID's.
func ScanIdIngredientArray(rs *sql.Rows) ([]IdIngredient, error) {
	defer rs.Close()
	ints := make([]IdIngredient, 0, 16)
	var err error
	for rs.Next() {
		var s IdIngredient
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

type IdIngredientSet map[IdIngredient]bool

func NewIdIngredientSetFrom(ids []IdIngredient) IdIngredientSet {
	out := make(IdIngredientSet, len(ids))
	for _, key := range ids {
		out[key] = true
	}
	return out
}

func (s IdIngredientSet) Add(id IdIngredient) { s[id] = true }

func (s IdIngredientSet) Has(id IdIngredient) bool { return s[id] }

func (s IdIngredientSet) Keys() []IdIngredient {
	out := make([]IdIngredient, 0, len(s))
	for k := range s {
		out = append(out, k)
	}
	return out
}

func IdMenuArrayToPQ(ids []IdMenu) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdMenuArray scans the result of a query returning a
// list of ID's.
func ScanIdMenuArray(rs *sql.Rows) ([]IdMenu, error) {
	defer rs.Close()
	ints := make([]IdMenu, 0, 16)
	var err error
	for rs.Next() {
		var s IdMenu
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

type IdMenuSet map[IdMenu]bool

func NewIdMenuSetFrom(ids []IdMenu) IdMenuSet {
	out := make(IdMenuSet, len(ids))
	for _, key := range ids {
		out[key] = true
	}
	return out
}

func (s IdMenuSet) Add(id IdMenu) { s[id] = true }

func (s IdMenuSet) Has(id IdMenu) bool { return s[id] }

func (s IdMenuSet) Keys() []IdMenu {
	out := make([]IdMenu, 0, len(s))
	for k := range s {
		out = append(out, k)
	}
	return out
}

func IdReceipeArrayToPQ(ids []IdReceipe) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdReceipeArray scans the result of a query returning a
// list of ID's.
func ScanIdReceipeArray(rs *sql.Rows) ([]IdReceipe, error) {
	defer rs.Close()
	ints := make([]IdReceipe, 0, 16)
	var err error
	for rs.Next() {
		var s IdReceipe
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

type IdReceipeSet map[IdReceipe]bool

func NewIdReceipeSetFrom(ids []IdReceipe) IdReceipeSet {
	out := make(IdReceipeSet, len(ids))
	for _, key := range ids {
		out[key] = true
	}
	return out
}

func (s IdReceipeSet) Add(id IdReceipe) { s[id] = true }

func (s IdReceipeSet) Has(id IdReceipe) bool { return s[id] }

func (s IdReceipeSet) Keys() []IdReceipe {
	out := make([]IdReceipe, 0, len(s))
	for k := range s {
		out = append(out, k)
	}
	return out
}

func (s *QuantityR) Scan(src interface{}) error  { return loadJSON(s, src) }
func (s QuantityR) Value() (driver.Value, error) { return dumpJSON(s) }
