package orders

// Code generated by gomacro/generator/go/sqlcrud. DO NOT EDIT.

import (
	"database/sql"

	"github.com/benoitkugler/atable/sql/menus"
	"github.com/benoitkugler/atable/sql/users"
	"github.com/lib/pq"
)

type scanner interface {
	Scan(...interface{}) error
}

// DB groups transaction like objects, and
// is implemented by *sql.DB and *sql.Tx
type DB interface {
	Exec(query string, args ...interface{}) (sql.Result, error)
	Query(query string, args ...interface{}) (*sql.Rows, error)
	QueryRow(query string, args ...interface{}) *sql.Row
	Prepare(query string) (*sql.Stmt, error)
}

func scanOneIngredientSupplier(row scanner) (IngredientSupplier, error) {
	var item IngredientSupplier
	err := row.Scan(
		&item.IdIngredient,
		&item.IdSupplier,
		&item.IdProfile,
	)
	return item, err
}

func ScanIngredientSupplier(row *sql.Row) (IngredientSupplier, error) {
	return scanOneIngredientSupplier(row)
}

// SelectAll returns all the items in the ingredient_suppliers table.
func SelectAllIngredientSuppliers(db DB) (IngredientSuppliers, error) {
	rows, err := db.Query("SELECT * FROM ingredient_suppliers")
	if err != nil {
		return nil, err
	}
	return ScanIngredientSuppliers(rows)
}

type IngredientSuppliers []IngredientSupplier

func ScanIngredientSuppliers(rs *sql.Rows) (IngredientSuppliers, error) {
	var (
		item IngredientSupplier
		err  error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(IngredientSuppliers, 0, 16)
	for rs.Next() {
		item, err = scanOneIngredientSupplier(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, item)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

func InsertIngredientSupplier(db DB, item IngredientSupplier) error {
	_, err := db.Exec(`INSERT INTO ingredient_suppliers (
			idingredient, idsupplier, idprofile
			) VALUES (
			$1, $2, $3
			);
			`, item.IdIngredient, item.IdSupplier, item.IdProfile)
	if err != nil {
		return err
	}
	return nil
}

// Insert the links IngredientSupplier in the database.
// It is a no-op if 'items' is empty.
func InsertManyIngredientSuppliers(tx *sql.Tx, items ...IngredientSupplier) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("ingredient_suppliers",
		"idingredient",
		"idsupplier",
		"idprofile",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdIngredient, item.IdSupplier, item.IdProfile)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link IngredientSupplier from the database.
// Only the foreign keys IdIngredient, IdSupplier, IdProfile fields are used in 'item'.
func (item IngredientSupplier) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM ingredient_suppliers WHERE IdIngredient = $1 AND IdSupplier = $2 AND IdProfile = $3;`, item.IdIngredient, item.IdSupplier, item.IdProfile)
	return err
}

// ByIdIngredient returns a map with 'IdIngredient' as keys.
func (items IngredientSuppliers) ByIdIngredient() map[menus.IdIngredient]IngredientSuppliers {
	out := make(map[menus.IdIngredient]IngredientSuppliers)
	for _, target := range items {
		out[target.IdIngredient] = append(out[target.IdIngredient], target)
	}
	return out
}

// IdIngredients returns the list of ids of IdIngredient
// contained in this link table.
// They are not garanteed to be distinct.
func (items IngredientSuppliers) IdIngredients() []menus.IdIngredient {
	out := make([]menus.IdIngredient, len(items))
	for index, target := range items {
		out[index] = target.IdIngredient
	}
	return out
}

func SelectIngredientSuppliersByIdIngredients(tx DB, idIngredients_ ...menus.IdIngredient) (IngredientSuppliers, error) {
	rows, err := tx.Query("SELECT * FROM ingredient_suppliers WHERE idingredient = ANY($1)", menus.IdIngredientArrayToPQ(idIngredients_))
	if err != nil {
		return nil, err
	}
	return ScanIngredientSuppliers(rows)
}

func DeleteIngredientSuppliersByIdIngredients(tx DB, idIngredients_ ...menus.IdIngredient) (IngredientSuppliers, error) {
	rows, err := tx.Query("DELETE FROM ingredient_suppliers WHERE idingredient = ANY($1) RETURNING *", menus.IdIngredientArrayToPQ(idIngredients_))
	if err != nil {
		return nil, err
	}
	return ScanIngredientSuppliers(rows)
}

// ByIdSupplier returns a map with 'IdSupplier' as keys.
func (items IngredientSuppliers) ByIdSupplier() map[IdSupplier]IngredientSuppliers {
	out := make(map[IdSupplier]IngredientSuppliers)
	for _, target := range items {
		out[target.IdSupplier] = append(out[target.IdSupplier], target)
	}
	return out
}

// IdSuppliers returns the list of ids of IdSupplier
// contained in this link table.
// They are not garanteed to be distinct.
func (items IngredientSuppliers) IdSuppliers() []IdSupplier {
	out := make([]IdSupplier, len(items))
	for index, target := range items {
		out[index] = target.IdSupplier
	}
	return out
}

func SelectIngredientSuppliersByIdSuppliers(tx DB, idSuppliers_ ...IdSupplier) (IngredientSuppliers, error) {
	rows, err := tx.Query("SELECT * FROM ingredient_suppliers WHERE idsupplier = ANY($1)", IdSupplierArrayToPQ(idSuppliers_))
	if err != nil {
		return nil, err
	}
	return ScanIngredientSuppliers(rows)
}

func DeleteIngredientSuppliersByIdSuppliers(tx DB, idSuppliers_ ...IdSupplier) (IngredientSuppliers, error) {
	rows, err := tx.Query("DELETE FROM ingredient_suppliers WHERE idsupplier = ANY($1) RETURNING *", IdSupplierArrayToPQ(idSuppliers_))
	if err != nil {
		return nil, err
	}
	return ScanIngredientSuppliers(rows)
}

// ByIdProfile returns a map with 'IdProfile' as keys.
func (items IngredientSuppliers) ByIdProfile() map[IdProfile]IngredientSuppliers {
	out := make(map[IdProfile]IngredientSuppliers)
	for _, target := range items {
		out[target.IdProfile] = append(out[target.IdProfile], target)
	}
	return out
}

// IdProfiles returns the list of ids of IdProfile
// contained in this link table.
// They are not garanteed to be distinct.
func (items IngredientSuppliers) IdProfiles() []IdProfile {
	out := make([]IdProfile, len(items))
	for index, target := range items {
		out[index] = target.IdProfile
	}
	return out
}

func SelectIngredientSuppliersByIdProfiles(tx DB, idProfiles_ ...IdProfile) (IngredientSuppliers, error) {
	rows, err := tx.Query("SELECT * FROM ingredient_suppliers WHERE idprofile = ANY($1)", IdProfileArrayToPQ(idProfiles_))
	if err != nil {
		return nil, err
	}
	return ScanIngredientSuppliers(rows)
}

func DeleteIngredientSuppliersByIdProfiles(tx DB, idProfiles_ ...IdProfile) (IngredientSuppliers, error) {
	rows, err := tx.Query("DELETE FROM ingredient_suppliers WHERE idprofile = ANY($1) RETURNING *", IdProfileArrayToPQ(idProfiles_))
	if err != nil {
		return nil, err
	}
	return ScanIngredientSuppliers(rows)
}

// SelectIngredientSuppliersByIdProfileAndIdIngredient selects the items matching the given fields.
func SelectIngredientSuppliersByIdProfileAndIdIngredient(tx DB, idProfile IdProfile, idIngredient menus.IdIngredient) (item IngredientSuppliers, err error) {
	rows, err := tx.Query("SELECT * FROM ingredient_suppliers WHERE IdProfile = $1 AND IdIngredient = $2", idProfile, idIngredient)
	if err != nil {
		return nil, err
	}
	return ScanIngredientSuppliers(rows)
}

// DeleteIngredientSuppliersByIdProfileAndIdIngredient deletes the item matching the given fields, returning
// the deleted items.
func DeleteIngredientSuppliersByIdProfileAndIdIngredient(tx DB, idProfile IdProfile, idIngredient menus.IdIngredient) (item IngredientSuppliers, err error) {
	rows, err := tx.Query("DELETE FROM ingredient_suppliers WHERE IdProfile = $1 AND IdIngredient = $2 RETURNING *", idProfile, idIngredient)
	if err != nil {
		return nil, err
	}
	return ScanIngredientSuppliers(rows)
}

// SelectIngredientSupplierByIdProfileAndIdIngredient return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectIngredientSupplierByIdProfileAndIdIngredient(tx DB, idProfile IdProfile, idIngredient menus.IdIngredient) (item IngredientSupplier, found bool, err error) {
	row := tx.QueryRow("SELECT * FROM ingredient_suppliers WHERE IdProfile = $1 AND IdIngredient = $2", idProfile, idIngredient)
	item, err = ScanIngredientSupplier(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func scanOneIngredientkindSupplier(row scanner) (IngredientkindSupplier, error) {
	var item IngredientkindSupplier
	err := row.Scan(
		&item.Kind,
		&item.IdSupplier,
		&item.IdProfile,
	)
	return item, err
}

func ScanIngredientkindSupplier(row *sql.Row) (IngredientkindSupplier, error) {
	return scanOneIngredientkindSupplier(row)
}

// SelectAll returns all the items in the ingredientkind_suppliers table.
func SelectAllIngredientkindSuppliers(db DB) (IngredientkindSuppliers, error) {
	rows, err := db.Query("SELECT * FROM ingredientkind_suppliers")
	if err != nil {
		return nil, err
	}
	return ScanIngredientkindSuppliers(rows)
}

type IngredientkindSuppliers []IngredientkindSupplier

func ScanIngredientkindSuppliers(rs *sql.Rows) (IngredientkindSuppliers, error) {
	var (
		item IngredientkindSupplier
		err  error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(IngredientkindSuppliers, 0, 16)
	for rs.Next() {
		item, err = scanOneIngredientkindSupplier(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, item)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

func InsertIngredientkindSupplier(db DB, item IngredientkindSupplier) error {
	_, err := db.Exec(`INSERT INTO ingredientkind_suppliers (
			kind, idsupplier, idprofile
			) VALUES (
			$1, $2, $3
			);
			`, item.Kind, item.IdSupplier, item.IdProfile)
	if err != nil {
		return err
	}
	return nil
}

// Insert the links IngredientkindSupplier in the database.
// It is a no-op if 'items' is empty.
func InsertManyIngredientkindSuppliers(tx *sql.Tx, items ...IngredientkindSupplier) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("ingredientkind_suppliers",
		"kind",
		"idsupplier",
		"idprofile",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.Kind, item.IdSupplier, item.IdProfile)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link IngredientkindSupplier from the database.
// Only the foreign keys IdSupplier, IdProfile fields are used in 'item'.
func (item IngredientkindSupplier) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM ingredientkind_suppliers WHERE IdSupplier = $1 AND IdProfile = $2;`, item.IdSupplier, item.IdProfile)
	return err
}

// ByIdSupplier returns a map with 'IdSupplier' as keys.
func (items IngredientkindSuppliers) ByIdSupplier() map[IdSupplier]IngredientkindSuppliers {
	out := make(map[IdSupplier]IngredientkindSuppliers)
	for _, target := range items {
		out[target.IdSupplier] = append(out[target.IdSupplier], target)
	}
	return out
}

// IdSuppliers returns the list of ids of IdSupplier
// contained in this link table.
// They are not garanteed to be distinct.
func (items IngredientkindSuppliers) IdSuppliers() []IdSupplier {
	out := make([]IdSupplier, len(items))
	for index, target := range items {
		out[index] = target.IdSupplier
	}
	return out
}

func SelectIngredientkindSuppliersByIdSuppliers(tx DB, idSuppliers_ ...IdSupplier) (IngredientkindSuppliers, error) {
	rows, err := tx.Query("SELECT * FROM ingredientkind_suppliers WHERE idsupplier = ANY($1)", IdSupplierArrayToPQ(idSuppliers_))
	if err != nil {
		return nil, err
	}
	return ScanIngredientkindSuppliers(rows)
}

func DeleteIngredientkindSuppliersByIdSuppliers(tx DB, idSuppliers_ ...IdSupplier) (IngredientkindSuppliers, error) {
	rows, err := tx.Query("DELETE FROM ingredientkind_suppliers WHERE idsupplier = ANY($1) RETURNING *", IdSupplierArrayToPQ(idSuppliers_))
	if err != nil {
		return nil, err
	}
	return ScanIngredientkindSuppliers(rows)
}

// ByIdProfile returns a map with 'IdProfile' as keys.
func (items IngredientkindSuppliers) ByIdProfile() map[IdProfile]IngredientkindSuppliers {
	out := make(map[IdProfile]IngredientkindSuppliers)
	for _, target := range items {
		out[target.IdProfile] = append(out[target.IdProfile], target)
	}
	return out
}

// IdProfiles returns the list of ids of IdProfile
// contained in this link table.
// They are not garanteed to be distinct.
func (items IngredientkindSuppliers) IdProfiles() []IdProfile {
	out := make([]IdProfile, len(items))
	for index, target := range items {
		out[index] = target.IdProfile
	}
	return out
}

func SelectIngredientkindSuppliersByIdProfiles(tx DB, idProfiles_ ...IdProfile) (IngredientkindSuppliers, error) {
	rows, err := tx.Query("SELECT * FROM ingredientkind_suppliers WHERE idprofile = ANY($1)", IdProfileArrayToPQ(idProfiles_))
	if err != nil {
		return nil, err
	}
	return ScanIngredientkindSuppliers(rows)
}

func DeleteIngredientkindSuppliersByIdProfiles(tx DB, idProfiles_ ...IdProfile) (IngredientkindSuppliers, error) {
	rows, err := tx.Query("DELETE FROM ingredientkind_suppliers WHERE idprofile = ANY($1) RETURNING *", IdProfileArrayToPQ(idProfiles_))
	if err != nil {
		return nil, err
	}
	return ScanIngredientkindSuppliers(rows)
}

// SelectIngredientkindSupplierByIdProfileAndKind return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectIngredientkindSupplierByIdProfileAndKind(tx DB, idProfile IdProfile, kind menus.IngredientKind) (item IngredientkindSupplier, found bool, err error) {
	row := tx.QueryRow("SELECT * FROM ingredientkind_suppliers WHERE IdProfile = $1 AND Kind = $2", idProfile, kind)
	item, err = ScanIngredientkindSupplier(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func scanOneProfile(row scanner) (Profile, error) {
	var item Profile
	err := row.Scan(
		&item.Id,
		&item.IdOwner,
		&item.Name,
	)
	return item, err
}

func ScanProfile(row *sql.Row) (Profile, error) { return scanOneProfile(row) }

// SelectAll returns all the items in the profiles table.
func SelectAllProfiles(db DB) (Profiles, error) {
	rows, err := db.Query("SELECT * FROM profiles")
	if err != nil {
		return nil, err
	}
	return ScanProfiles(rows)
}

// SelectProfile returns the entry matching 'id'.
func SelectProfile(tx DB, id IdProfile) (Profile, error) {
	row := tx.QueryRow("SELECT * FROM profiles WHERE id = $1", id)
	return ScanProfile(row)
}

// SelectProfiles returns the entry matching the given 'ids'.
func SelectProfiles(tx DB, ids ...IdProfile) (Profiles, error) {
	rows, err := tx.Query("SELECT * FROM profiles WHERE id = ANY($1)", IdProfileArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanProfiles(rows)
}

type Profiles map[IdProfile]Profile

func (m Profiles) IDs() []IdProfile {
	out := make([]IdProfile, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanProfiles(rs *sql.Rows) (Profiles, error) {
	var (
		s   Profile
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Profiles, 16)
	for rs.Next() {
		s, err = scanOneProfile(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Profile in the database and returns the item with id filled.
func (item Profile) Insert(tx DB) (out Profile, err error) {
	row := tx.QueryRow(`INSERT INTO profiles (
		idowner, name
		) VALUES (
		$1, $2
		) RETURNING *;
		`, item.IdOwner, item.Name)
	return ScanProfile(row)
}

// Update Profile in the database and returns the new version.
func (item Profile) Update(tx DB) (out Profile, err error) {
	row := tx.QueryRow(`UPDATE profiles SET (
		idowner, name
		) = (
		$1, $2
		) WHERE id = $3 RETURNING *;
		`, item.IdOwner, item.Name, item.Id)
	return ScanProfile(row)
}

// Deletes the Profile and returns the item
func DeleteProfileById(tx DB, id IdProfile) (Profile, error) {
	row := tx.QueryRow("DELETE FROM profiles WHERE id = $1 RETURNING *;", id)
	return ScanProfile(row)
}

// Deletes the Profile in the database and returns the ids.
func DeleteProfilesByIDs(tx DB, ids ...IdProfile) ([]IdProfile, error) {
	rows, err := tx.Query("DELETE FROM profiles WHERE id = ANY($1) RETURNING id", IdProfileArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdProfileArray(rows)
}

// ByIdOwner returns a map with 'IdOwner' as keys.
func (items Profiles) ByIdOwner() map[users.IdUser]Profiles {
	out := make(map[users.IdUser]Profiles)
	for _, target := range items {
		dict := out[target.IdOwner]
		if dict == nil {
			dict = make(Profiles)
		}
		dict[target.Id] = target
		out[target.IdOwner] = dict
	}
	return out
}

// IdOwners returns the list of ids of IdOwner
// contained in this table.
// They are not garanteed to be distinct.
func (items Profiles) IdOwners() []users.IdUser {
	out := make([]users.IdUser, 0, len(items))
	for _, target := range items {
		out = append(out, target.IdOwner)
	}
	return out
}

func SelectProfilesByIdOwners(tx DB, idOwners_ ...users.IdUser) (Profiles, error) {
	rows, err := tx.Query("SELECT * FROM profiles WHERE idowner = ANY($1)", users.IdUserArrayToPQ(idOwners_))
	if err != nil {
		return nil, err
	}
	return ScanProfiles(rows)
}

func DeleteProfilesByIdOwners(tx DB, idOwners_ ...users.IdUser) ([]IdProfile, error) {
	rows, err := tx.Query("DELETE FROM profiles WHERE idowner = ANY($1) RETURNING id", users.IdUserArrayToPQ(idOwners_))
	if err != nil {
		return nil, err
	}
	return ScanIdProfileArray(rows)
}

func scanOneSupplier(row scanner) (Supplier, error) {
	var item Supplier
	err := row.Scan(
		&item.Id,
		&item.IdProfile,
		&item.Name,
	)
	return item, err
}

func ScanSupplier(row *sql.Row) (Supplier, error) { return scanOneSupplier(row) }

// SelectAll returns all the items in the suppliers table.
func SelectAllSuppliers(db DB) (Suppliers, error) {
	rows, err := db.Query("SELECT * FROM suppliers")
	if err != nil {
		return nil, err
	}
	return ScanSuppliers(rows)
}

// SelectSupplier returns the entry matching 'id'.
func SelectSupplier(tx DB, id IdSupplier) (Supplier, error) {
	row := tx.QueryRow("SELECT * FROM suppliers WHERE id = $1", id)
	return ScanSupplier(row)
}

// SelectSuppliers returns the entry matching the given 'ids'.
func SelectSuppliers(tx DB, ids ...IdSupplier) (Suppliers, error) {
	rows, err := tx.Query("SELECT * FROM suppliers WHERE id = ANY($1)", IdSupplierArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanSuppliers(rows)
}

type Suppliers map[IdSupplier]Supplier

func (m Suppliers) IDs() []IdSupplier {
	out := make([]IdSupplier, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanSuppliers(rs *sql.Rows) (Suppliers, error) {
	var (
		s   Supplier
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Suppliers, 16)
	for rs.Next() {
		s, err = scanOneSupplier(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Supplier in the database and returns the item with id filled.
func (item Supplier) Insert(tx DB) (out Supplier, err error) {
	row := tx.QueryRow(`INSERT INTO suppliers (
		idprofile, name
		) VALUES (
		$1, $2
		) RETURNING *;
		`, item.IdProfile, item.Name)
	return ScanSupplier(row)
}

// Update Supplier in the database and returns the new version.
func (item Supplier) Update(tx DB) (out Supplier, err error) {
	row := tx.QueryRow(`UPDATE suppliers SET (
		idprofile, name
		) = (
		$1, $2
		) WHERE id = $3 RETURNING *;
		`, item.IdProfile, item.Name, item.Id)
	return ScanSupplier(row)
}

// Deletes the Supplier and returns the item
func DeleteSupplierById(tx DB, id IdSupplier) (Supplier, error) {
	row := tx.QueryRow("DELETE FROM suppliers WHERE id = $1 RETURNING *;", id)
	return ScanSupplier(row)
}

// Deletes the Supplier in the database and returns the ids.
func DeleteSuppliersByIDs(tx DB, ids ...IdSupplier) ([]IdSupplier, error) {
	rows, err := tx.Query("DELETE FROM suppliers WHERE id = ANY($1) RETURNING id", IdSupplierArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdSupplierArray(rows)
}

// ByIdProfile returns a map with 'IdProfile' as keys.
func (items Suppliers) ByIdProfile() map[IdProfile]Suppliers {
	out := make(map[IdProfile]Suppliers)
	for _, target := range items {
		dict := out[target.IdProfile]
		if dict == nil {
			dict = make(Suppliers)
		}
		dict[target.Id] = target
		out[target.IdProfile] = dict
	}
	return out
}

// IdProfiles returns the list of ids of IdProfile
// contained in this table.
// They are not garanteed to be distinct.
func (items Suppliers) IdProfiles() []IdProfile {
	out := make([]IdProfile, 0, len(items))
	for _, target := range items {
		out = append(out, target.IdProfile)
	}
	return out
}

func SelectSuppliersByIdProfiles(tx DB, idProfiles_ ...IdProfile) (Suppliers, error) {
	rows, err := tx.Query("SELECT * FROM suppliers WHERE idprofile = ANY($1)", IdProfileArrayToPQ(idProfiles_))
	if err != nil {
		return nil, err
	}
	return ScanSuppliers(rows)
}

func DeleteSuppliersByIdProfiles(tx DB, idProfiles_ ...IdProfile) ([]IdSupplier, error) {
	rows, err := tx.Query("DELETE FROM suppliers WHERE idprofile = ANY($1) RETURNING id", IdProfileArrayToPQ(idProfiles_))
	if err != nil {
		return nil, err
	}
	return ScanIdSupplierArray(rows)
}

// SelectSupplierByIdAndIdProfile return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectSupplierByIdAndIdProfile(tx DB, id IdSupplier, idProfile IdProfile) (item Supplier, found bool, err error) {
	row := tx.QueryRow("SELECT * FROM suppliers WHERE Id = $1 AND IdProfile = $2", id, idProfile)
	item, err = ScanSupplier(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func IdProfileArrayToPQ(ids []IdProfile) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdProfileArray scans the result of a query returning a
// list of ID's.
func ScanIdProfileArray(rs *sql.Rows) ([]IdProfile, error) {
	defer rs.Close()
	ints := make([]IdProfile, 0, 16)
	var err error
	for rs.Next() {
		var s IdProfile
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

type IdProfileSet map[IdProfile]bool

func NewIdProfileSetFrom(ids []IdProfile) IdProfileSet {
	out := make(IdProfileSet, len(ids))
	for _, key := range ids {
		out[key] = true
	}
	return out
}

func (s IdProfileSet) Add(id IdProfile) { s[id] = true }

func (s IdProfileSet) Has(id IdProfile) bool { return s[id] }

func (s IdProfileSet) Keys() []IdProfile {
	out := make([]IdProfile, 0, len(s))
	for k := range s {
		out = append(out, k)
	}
	return out
}

func IdSupplierArrayToPQ(ids []IdSupplier) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdSupplierArray scans the result of a query returning a
// list of ID's.
func ScanIdSupplierArray(rs *sql.Rows) ([]IdSupplier, error) {
	defer rs.Close()
	ints := make([]IdSupplier, 0, 16)
	var err error
	for rs.Next() {
		var s IdSupplier
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

type IdSupplierSet map[IdSupplier]bool

func NewIdSupplierSetFrom(ids []IdSupplier) IdSupplierSet {
	out := make(IdSupplierSet, len(ids))
	for _, key := range ids {
		out[key] = true
	}
	return out
}

func (s IdSupplierSet) Add(id IdSupplier) { s[id] = true }

func (s IdSupplierSet) Has(id IdSupplier) bool { return s[id] }

func (s IdSupplierSet) Keys() []IdSupplier {
	out := make([]IdSupplier, 0, len(s))
	for k := range s {
		out = append(out, k)
	}
	return out
}
